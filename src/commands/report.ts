import chalk from 'chalk';
import { scanRepository } from '../services/scanner';
import { calculateScore, ScoreResult } from '../services/scorer';
import { MATURITY_LEVELS } from '../models/levels';

export type ReportFormat = 'json' | 'markdown' | 'terminal';

export async function reportCommand(
  targetPath: string,
  format: ReportFormat
): Promise<void> {
  try {
    const scanResult = await scanRepository(targetPath);
    const score = calculateScore(scanResult);

    switch (format) {
      case 'json':
        printJsonReport(score, scanResult.basePath);
        break;
      case 'markdown':
        printMarkdownReport(score, scanResult.basePath);
        break;
      case 'terminal':
      default:
        // Reuse scan command's terminal output
        const { scanCommand } = await import('./scan');
        await scanCommand(targetPath);
        break;
    }
  } catch (error) {
    console.error(chalk.red(`Error: ${(error as Error).message}`));
    process.exit(1);
  }
}

function printJsonReport(score: ScoreResult, basePath: string): void {
  const report = {
    repository: basePath,
    timestamp: new Date().toISOString(),
    maturity: {
      level: score.maturityLevel,
      name: score.maturityName,
      description: score.maturityDescription
    },
    quality: {
      score: score.qualityScore,
      maxScore: 10,
      weight: score.totalWeight
    },
    metrics: score.qualityMetrics,
    tools: score.toolBreakdown,
    recommendations: score.recommendations,
    levels: MATURITY_LEVELS.map(l => ({
      level: l.level,
      name: l.name,
      achieved: l.level <= score.maturityLevel
    }))
  };

  console.log(JSON.stringify(report, null, 2));
}

function printMarkdownReport(score: ScoreResult, basePath: string): void {
  const lines: string[] = [];

  lines.push('# Context Frame Report\n');
  lines.push(`**Repository:** \`${basePath}\`\n`);
  lines.push(`**Generated:** ${new Date().toISOString()}\n`);

  // Maturity Level
  lines.push('## Maturity Level\n');
  lines.push(`| Level | Status |`);
  lines.push(`|-------|--------|`);
  for (const level of MATURITY_LEVELS) {
    const status = level.level <= score.maturityLevel ? '✅' : '⬜';
    const current = level.level === score.maturityLevel ? ' ← Current' : '';
    lines.push(`| ${level.level}. ${level.name} | ${status}${current} |`);
  }
  lines.push('');

  lines.push(`**Current Level:** ${score.maturityLevel} - ${score.maturityName}\n`);
  lines.push(`> ${score.maturityDescription}\n`);

  // Quality Score
  lines.push('## Quality Score\n');
  lines.push(`**Score:** ${score.qualityScore}/10\n`);
  lines.push(`**Total Weight:** ${score.totalWeight}\n`);

  // Progress bar in markdown
  const filled = Math.round(score.qualityScore);
  const bar = '█'.repeat(filled) + '░'.repeat(10 - filled);
  lines.push(`\`${bar}\`\n`);

  // Metrics
  lines.push('## Quality Metrics\n');
  lines.push('| Metric | Value |');
  lines.push('|--------|-------|');
  lines.push(`| Sections | ${score.qualityMetrics.sections} |`);
  lines.push(`| File Paths | ${score.qualityMetrics.filePaths} |`);
  lines.push(`| Commands | ${score.qualityMetrics.commands} |`);
  lines.push(`| Constraints | ${score.qualityMetrics.constraints} |`);
  lines.push(`| Word Count | ${score.qualityMetrics.wordCount} |`);
  lines.push('');

  // Tool Coverage
  lines.push('## Tool Coverage\n');
  if (Object.keys(score.toolBreakdown).length === 0) {
    lines.push('*No AI context files detected*\n');
  } else {
    for (const [tool, data] of Object.entries(score.toolBreakdown)) {
      lines.push(`### ${tool}\n`);
      lines.push(`**Weight:** ${data.weight}\n`);
      lines.push('**Files:**');
      for (const file of data.files) {
        lines.push(`- \`${file}\``);
      }
      lines.push('');
    }
  }

  // Recommendations
  if (score.recommendations.length > 0) {
    lines.push('## Recommendations\n');
    for (const rec of score.recommendations) {
      lines.push(`- ${rec}`);
    }
    lines.push('');
  }

  // Footer
  lines.push('---');
  lines.push('*Generated by [Context Frame](https://github.com/context-frame)*');

  console.log(lines.join('\n'));
}
